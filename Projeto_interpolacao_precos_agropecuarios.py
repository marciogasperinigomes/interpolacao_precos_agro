# -*- coding: utf-8 -*-
"""Projeto_Interpolacao_precos_agropecuarios .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xEw5epV2GYEAd_Ot18fW1TTxUzcpUm-8

Testando interpolação de preços agropecuários na tabela de preços agropecuários das regiões agro: v_fat_preco_produto_media_praca_ao
"""

# Importando pacotes:
import pandas as pd

# Carregando o arquivo e apresentando uma amostra da tabela:

df = pd.read_excel('/content/drive/MyDrive/2. Projetos de ciência de dados/Interpolação Preços Agropecuários /v_fat_preco_produto_media_praca_ao.xlsx')
df.head()

# Verificando tamnho e tipos:
df.info()

# Alterando a coluna de dat_movimento do formato texto para data:
df['dat_movimento']=pd.to_datetime(df['dat_movimento'],format='%Y-%m-%d')

# Classificando o DataFrame pela coluna 'Data' para garantir que as datas estejam em ordem
df.sort_values(by='dat_movimento', inplace=True)

# Agrupando os dados por 'Produto'
grouped = df.groupby('dsc_produto')

# Observando como ficou o DF:
display(df)

# Criando um DataFrame com todas as combinações de Produto, Data e Praça
produtos = df['dsc_produto'].unique()
pracas = df['dsc_praca'].unique()
datas = pd.date_range(start=df['dat_movimento'].min(), end=df['dat_movimento'].max(), freq='MS')
combinacoes_produto_data_pracas_valor = pd.MultiIndex.from_product([produtos, datas,pracas], names=['dsc_produto', 'dat_movimento','dsc_praca'])
df_completo = pd.DataFrame(index=combinacoes_produto_data_pracas_valor).reset_index()

#Conferindo como ficou o df_completo:
display(df_completo)

# Filtra as colunas relevantes para concatenação
df_concat = df[['dsc_produto', 'dat_movimento', 'val_mais_comum', 'dsc_praca']].copy()

# Conferindo como ficou o df_concat:
display(df_concat)

# Suponha que 'df_completo' e 'df_concat' sejam seus DataFrames
# Realiza a junção dos DataFrames com base na coluna em comum ('dat_movimento')
df_merged = pd.merge(df_completo, df_concat, on='dat_movimento', how='outer', indicator=True)
display(df_merged)
# Filtra as linhas que estão apenas em um dos DataFrames
df_diferenca = df_merged[df_merged['_merge'] != 'both']

# Remove a coluna indicadora '_merge'
df_diferenca.drop(columns=['_merge'], inplace=True)

# Agora df_diferenca contém apenas as linhas com datas diferentes entre os DataFrames
display(df_diferenca)

# Adiciona as linhas ausentes usando concatenação, isto é: concatena "df_completo" + "df_concat" para obter "df_interpolado".
df_interpolado = pd.concat([df_completo, df_concat], ignore_index=True, sort=False)

#Conferindo como ficou o df_interpolado:
display(df_interpolado)

# Classifica o DataFrame resultante
df_interpolado.sort_values(by=['dsc_produto', 'dat_movimento'], inplace=True)

# Conferindo novamente como ficou o df_interpolado:
display(df_interpolado)

# Preenche os valores ausentes usando o método 'ffill' (preenchimento para frente) dentro de cada grupo de produtos
df_interpolado['val_mais_comum'] = df_interpolado.groupby('dsc_produto')['val_mais_comum'].ffill()

# O DataFrame resultante (df_interpolado) agora contém os valores interpolados

display(df_interpolado)

# Exportando para excel o DataFrame resultante (df_interpolated)
df_interpolado.to_excel('df_interpolado.xlsx')